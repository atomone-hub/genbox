package main

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/peterbourgon/ff/v3/ffcli"
	"golang.org/x/exp/maps"

	sdk "github.com/cosmos/cosmos-sdk/types"
)

func main() {
	rootCmd := &ffcli.Command{
		ShortUsage: "govbox <subcommand> <path>",
		ShortHelp:  "Set of commands for GovGen proposals.",
		Subcommands: []*ffcli.Command{
			tallyCmd(), accountsCmd(), genesisCmd(),
			autoStakingCmd(), distributionCmd(), topTenCmd(),
		},
		Exec: func(ctx context.Context, args []string) error {
			return flag.ErrHelp
		},
	}
	err := rootCmd.ParseAndRun(context.Background(), os.Args[1:])
	if err != nil && err != flag.ErrHelp {
		log.Fatal(err)
	}
}

func tallyCmd() *ffcli.Command {
	return &ffcli.Command{
		Name:       "tally",
		ShortUsage: "govbox tally <path>",
		ShortHelp:  "Print the comparison between the tally result and the tally computed from <path>",
		Exec: func(ctx context.Context, args []string) error {
			if len(args) == 0 {
				return flag.ErrHelp
			}
			datapath := args[0]
			votesByAddr, err := parseVotesByAddr(datapath)
			if err != nil {
				return err
			}
			valsByAddr, err := parseValidatorsByAddr(datapath, votesByAddr)
			if err != nil {
				return err
			}
			delegsByAddr, err := parseDelegationsByAddr(datapath)
			if err != nil {
				return err
			}
			results, totalVotingPower := tally(votesByAddr, valsByAddr, delegsByAddr)
			printTallyResults(results, totalVotingPower, parseProp(datapath))
			return nil
		},
	}
}

func accountsCmd() *ffcli.Command {
	return &ffcli.Command{
		Name:       "accounts",
		ShortUsage: "govbox accounts <path>",
		ShortHelp:  "Consolidate the data in <path> into a single file <path>/accounts.json",
		Exec: func(ctx context.Context, args []string) error {
			if len(args) == 0 {
				return flag.ErrHelp
			}
			var (
				datapath     = args[0]
				accountsFile = filepath.Join(datapath, "accounts.json")
			)
			votesByAddr, err := parseVotesByAddr(datapath)
			if err != nil {
				return err
			}
			valsByAddr, err := parseValidatorsByAddr(datapath, votesByAddr)
			if err != nil {
				return err
			}
			delegsByAddr, err := parseDelegationsByAddr(datapath)
			if err != nil {
				return err
			}
			balancesByAddr, err := parseBalancesByAddr(datapath, "uatom")
			if err != nil {
				return err
			}
			accountTypesByAddr, err := parseAccountTypesPerAddr(datapath)
			if err != nil {
				return err
			}

			accounts := getAccounts(delegsByAddr, votesByAddr, valsByAddr, balancesByAddr, accountTypesByAddr)

			bz, err := json.MarshalIndent(accounts, "", "  ")
			if err != nil {
				return err
			}
			if err := os.WriteFile(accountsFile, bz, 0o666); err != nil {
				return err
			}
			fmt.Printf("%s file created.\n", accountsFile)

			return nil
		},
	}
}

func genesisCmd() *ffcli.Command {
	return &ffcli.Command{
		Name:       "genesis",
		ShortUsage: "govbox genesis <path>",
		ShortHelp:  "Convert <path>/accounts.json to <path>/bank.genesis",
		LongHelp: `Generate the bank genesis for the GovGen distribution.
The command must be run once <path>/accounts.json is generated by the
'govbox accounts <path>' command`,
		Exec: func(ctx context.Context, args []string) error {
			if len(args) == 0 {
				return flag.ErrHelp
			}
			var (
				datapath        = args[0]
				accountsFile    = filepath.Join(datapath, "accounts.json")
				bankGenesisFile = filepath.Join(datapath, "bank.genesis")
			)
			accounts, err := parseAccounts(accountsFile)
			if err != nil {
				return err
			}
			if err := writeBankGenesis(accounts, bankGenesisFile); err != nil {
				return err
			}
			fmt.Printf("%s file created.\n", bankGenesisFile)
			return nil
		},
	}
}

func autoStakingCmd() *ffcli.Command {
	return &ffcli.Command{
		Name:       "autostaking",
		ShortUsage: "govbox autostaking <path>",
		ShortHelp:  "Experimental command to evaluate auto-staking algorithms",
		LongHelp:   `Final implementation in GovGen commit https://github.com/atomone-hub/govgen/commit/3c40c31`,
		Exec: func(ctx context.Context, args []string) error {
			if len(args) == 0 {
				return flag.ErrHelp
			}
			datapath := args[0]
			return autoStaking(filepath.Join(datapath, "genesis.json"))
		},
	}
}

func distributionCmd() *ffcli.Command {
	fs := flag.NewFlagSet("distribution", flag.ContinueOnError)
	chartMode := fs.Bool("chart", false, "Outputs a chart instead of Markdown tables")
	yesMultipliers := fs.String("yesMultipliers", "1", "List of possible comma-seperated Yes multipliers")
	noMultipliers := fs.String("noMultipliers", "4", "List of possible comma-separated No multipliers")

	cmd := &ffcli.Command{
		Name:       "distribution",
		ShortUsage: "govbox distribution <path>",
		ShortHelp:  "Convert <path>/accounts.json into <path>/airdrop.json",
		LongHelp:   `Generate the ATONE distribution described in GovGen PROP 001`,
		FlagSet:    fs,
		Exec: func(ctx context.Context, args []string) error {
			if len(args) == 0 {
				return flag.ErrHelp
			}
			fs.Parse(args)
			// Build distribution parameters from yes and no multipliers
			var distriParamss []distriParams
			for _, y := range strings.Split(*yesMultipliers, ",") {
				for _, n := range strings.Split(*noMultipliers, ",") {
					distriParams := defaultDistriParams()
					distriParams.yesVotesMultiplier = sdk.MustNewDecFromStr(y)
					distriParams.noVotesMultiplier = sdk.MustNewDecFromStr(n)
					distriParamss = append(distriParamss, distriParams)
				}
			}
			var (
				datapath     = args[0]
				accountsFile = filepath.Join(datapath, "accounts.json")
				airdropFile  = filepath.Join(datapath, "airdrop.json")
				airdrops     []airdrop
			)
			accounts, err := parseAccounts(accountsFile)
			if err != nil {
				return err
			}
			for _, params := range distriParamss {
				airdrop, err := distribution(accounts, params)
				if err != nil {
					return err
				}
				airdrops = append(airdrops, airdrop)
			}
			if len(airdrops) == 1 {
				// Write airdrop.json only if a single distriParamss
				bz, err := json.MarshalIndent(airdrops[0].addresses, "", "  ")
				if err != nil {
					return err
				}
				if err := os.WriteFile(airdropFile, bz, 0o666); err != nil {
					return err
				}
			}
			if err := printAirdropsStats(*chartMode, airdrops); err != nil {
				return err
			}
			return nil
		},
	}
	return cmd
}

func topTenCmd() *ffcli.Command {
	return &ffcli.Command{
		Name:       "topten",
		ShortUsage: "govbox topten <path>",
		ShortHelp:  "Prints the top richest addresses of <path>/airdrop.json",
		Exec: func(ctx context.Context, args []string) error {
			f, err := os.Open("data/prop848/airdrop.json")
			if err != nil {
				return err
			}
			defer f.Close()
			var addresses map[string]sdk.Int
			err = json.NewDecoder(f).Decode(&addresses)
			if err != nil {
				return err
			}
			adrs := maps.Keys(addresses)
			sort.Slice(adrs, func(i, j int) bool {
				return addresses[adrs[i]].GT(addresses[adrs[j]])
			})
			for i := 0; i < 10; i++ {
				fmt.Println(adrs[i], human(addresses[adrs[i]]))
			}
			t := sdk.NewInt(0)
			for _, v := range addresses {
				t = t.Add(v)
			}
			fmt.Println("TOTAL", human(t))
			return nil
		},
	}
}
